---
title: "cm103"
author: "Santiago David"
date: '2017-10-31'
output: github_document
---

An atomic vector is the one in which all elements are of the same type (not a list of mixed elements), for example

```{r}
# trick if you sorround the vector on parenthesis, it prints the content
(v_log <- c(TRUE, FALSE, FALSE, TRUE))
(v_int <- 1:4)
(v_double <- 1:4 * 1.2)
(v_char <- letters[1:4])
typeof(v_double)
typeof(v_char)
```

Now, we can use a sort of filter function to test a statement on the data, 
or index the data by logical statement
```{r}
v_char[c(FALSE, FALSE, TRUE, TRUE)]
v_char[v_log]
```
How do we index by position?
```{r}
v_double[2:3]
v_double[1]
v_char[-4]
```

We can mess up a vector by coercing it to a different type
```{r}
v_int[1]
typeof(v_int[1])
v_doub_copy <- v_double
str(v_doub_copy)
#now if we modified one value to character is gonna change the whole type of the vector
v_doub_copy[3] <- "uhoh"
str(v_doub_copy)
```

lists
```{r}
(x <- list(1:3, c("four", "five")))
(y <- list(logical = TRUE, integer = 4L, double = 4*1.2, character = "character"))
(z <- list(letters[26:22], trascendental = c(pi, exp(1)), f = function(x)x^2))
```

#### challenge, in list y, pull out the second and third elements, in list z pull out all the trascendental numbers

```{r}
y[2:3]
z[2]
z["trascendental"]
z$trascendental
```

